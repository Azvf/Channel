<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL æµ‹è¯•é¡µé¢</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: white;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .test-section {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .test-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #fff;
        }
        
        .test-result {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: monospace;
        }
        
        .success {
            background: rgba(76, 175, 80, 0.2);
            border: 1px solid rgba(76, 175, 80, 0.5);
        }
        
        .error {
            background: rgba(244, 67, 54, 0.2);
            border: 1px solid rgba(244, 67, 54, 0.5);
        }
        
        .warning {
            background: rgba(255, 193, 7, 0.2);
            border: 1px solid rgba(255, 193, 7, 0.5);
        }
        
        .canvas-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        
        .canvas-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }
        
        .canvas-item h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        
        canvas {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.2);
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .info-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .info-label {
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 5px;
        }
        
        .info-value {
            font-family: monospace;
            word-break: break-all;
        }
        
        button {
            background: rgba(76, 175, 80, 0.8);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: rgba(76, 175, 80, 1);
            transform: translateY(-2px);
        }
        
        .test-buttons {
            text-align: center;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 style="text-align: center; margin-bottom: 30px;">WebGL / WebGPU åŠŸèƒ½æµ‹è¯•é¡µé¢</h1>
        
        <!-- WebGL æ”¯æŒæ£€æµ‹ -->
        <div class="test-section">
            <div class="test-title">ğŸ” WebGL æ”¯æŒæ£€æµ‹</div>
            <div id="webgl-support-result" class="test-result">æ£€æµ‹ä¸­...</div>
            <div class="test-buttons">
                <button onclick="testWebGLSupport()">é‡æ–°æ£€æµ‹</button>
                <button onclick="testWebGLContexts()">æµ‹è¯•ä¸Šä¸‹æ–‡</button>
            </div>
        </div>

        <!-- WebGPU æ”¯æŒæ£€æµ‹ -->
        <div class="test-section">
            <div class="test-title">ğŸ§ª WebGPU æ”¯æŒæ£€æµ‹</div>
            <div id="webgpu-support-result" class="test-result">æœªæ£€æµ‹</div>
            <div class="test-buttons">
                <button onclick="testWebGPUSupport()">æ£€æµ‹ WebGPU</button>
                <button onclick="testWebGPUAdapterDevice()">è·å– Adapter/Device</button>
            </div>
        </div>
        
        <!-- WebGL ä¸Šä¸‹æ–‡ä¿¡æ¯ -->
        <div class="test-section">
            <div class="test-title">ğŸ“Š WebGL ä¸Šä¸‹æ–‡ä¿¡æ¯</div>
            <div id="webgl-info" class="info-grid"></div>
        </div>
        
        <!-- Canvas æµ‹è¯• -->
        <div class="test-section">
            <div class="test-title">ğŸ¨ Canvas æ¸²æŸ“æµ‹è¯•</div>
            <div class="canvas-container">
                <div class="canvas-item">
                    <h3>WebGL 1.0 æµ‹è¯•</h3>
                    <canvas id="webgl1-canvas" width="200" height="150"></canvas>
                    <div id="webgl1-result" class="test-result" style="margin-top: 10px;">æœªæµ‹è¯•</div>
                </div>
                <div class="canvas-item">
                    <h3>WebGL 2.0 æµ‹è¯•</h3>
                    <canvas id="webgl2-canvas" width="200" height="150"></canvas>
                    <div id="webgl2-result" class="test-result" style="margin-top: 10px;">æœªæµ‹è¯•</div>
                </div>
                <div class="canvas-item">
                    <h3>WebGPU æµ‹è¯•</h3>
                    <canvas id="webgpu-canvas" width="200" height="150"></canvas>
                    <div id="webgpu-result" class="test-result" style="margin-top: 10px;">æœªæµ‹è¯•</div>
                </div>
                <div class="canvas-item">
                    <h3>2D Canvas å¯¹æ¯”</h3>
                    <canvas id="2d-canvas" width="200" height="150"></canvas>
                    <div id="2d-result" class="test-result" style="margin-top: 10px;">å·²æ¸²æŸ“</div>
                </div>
            </div>
            <div class="test-buttons">
                <button onclick="testAllCanvases()">æµ‹è¯•æ‰€æœ‰ Canvas</button>
                <button onclick="clearAllCanvases()">æ¸…ç©ºæ‰€æœ‰ Canvas</button>
                <button onclick="testWebGPUCanvas()">æµ‹è¯• WebGPU æ¸²æŸ“</button>
            </div>
        </div>
        
        <!-- æ‰©å±•ç¯å¢ƒæ¨¡æ‹Ÿæµ‹è¯• -->
        <div class="test-section">
            <div class="test-title">ğŸ”§ æ‰©å±•ç¯å¢ƒæ¨¡æ‹Ÿæµ‹è¯•</div>
            <div id="extension-test-result" class="test-result">æœªæµ‹è¯•</div>
            <div class="test-buttons">
                <button onclick="testExtensionEnvironment()">æ¨¡æ‹Ÿæ‰©å±•ç¯å¢ƒ</button>
                <button onclick="testWebGLInExtension()">æµ‹è¯•æ‰©å±•ä¸­çš„ WebGL</button>
            </div>
        </div>
        
        <!-- æ€§èƒ½æµ‹è¯• -->
        <div class="test-section">
            <div class="test-title">âš¡ æ€§èƒ½æµ‹è¯•</div>
            <div id="performance-result" class="test-result">æœªæµ‹è¯•</div>
            <div class="test-buttons">
                <button onclick="testWebGLPerformance()">WebGL æ€§èƒ½æµ‹è¯•</button>
                <button onclick="testCanvasPerformance()">Canvas 2D æ€§èƒ½æµ‹è¯•</button>
            </div>
        </div>

        <!-- æ¯›ç»ç’ƒ Tag æµ‹è¯• -->
        <div class="test-section">
            <div class="test-title">ğŸ§Š æ¯›ç»ç’ƒ Tag å®æ—¶æ¸²æŸ“æµ‹è¯•</div>
            <div class="canvas-container" style="align-items: center;">
                <div class="canvas-item">
                    <h3>Canvas 2D å®æ—¶æ¸²æŸ“</h3>
                    <canvas id="glass-tag-canvas" width="300" height="80"></canvas>
                    <div style="margin-top:10px;">
                        <input id="glass-tag-text" placeholder="è¾“å…¥æ ‡ç­¾æ–‡æœ¬" value="GameplayTag" style="padding:6px 10px;border-radius:8px;border:none;outline:none;">
                        <button onclick="toggleRealTimeRendering()">å¼€å§‹/åœæ­¢å®æ—¶æ¸²æŸ“</button>
                    </div>
                    <div style="margin-top:8px;">
                        <label style="font-size:12px;color:rgba(255,255,255,0.8);">
                            <input type="checkbox" id="enable-animation" checked> å¯ç”¨åŠ¨ç”»æ•ˆæœ
                        </label>
                        <label style="font-size:12px;color:rgba(255,255,255,0.8);margin-left:15px;">
                            <input type="checkbox" id="enable-noise" checked> å¯ç”¨å™ªå£°æ•ˆæœ
                        </label>
                    </div>
                    <div id="glass-tag-result" class="test-result" style="margin-top: 10px;">æœªå¯åŠ¨</div>
                </div>
                <div class="canvas-item">
                    <h3>CSS ç»ç’ƒè´¨æ„Ÿå¯¹æ¯”</h3>
                    <div id="glass-tag-css" style="
                        display:inline-flex;align-items:center;justify-content:center;
                        min-width:200px;height:40px;padding:0 16px;
                        border-radius:20px;border:1px solid rgba(255,255,255,0.35);
                        color:#fff;font-weight:600;letter-spacing:0.2px;
                        background: linear-gradient(180deg, rgba(255,255,255,0.20), rgba(255,255,255,0.10));
                        box-shadow: 0 8px 32px rgba(0,0,0,0.18), inset 0 1px 0 rgba(255,255,255,0.25);
                        backdrop-filter: blur(12px) saturate(180%) brightness(110%);
                        -webkit-backdrop-filter: blur(12px) saturate(180%) brightness(110%);
                    ">GameplayTag</div>
                    <div style="margin-top:10px;">
                        <input id="glass-tag-css-text" placeholder="è¾“å…¥æ ‡ç­¾æ–‡æœ¬" value="GameplayTag" style="padding:6px 10px;border-radius:8px;border:none;outline:none;">
                        <button onclick="updateCssGlassTag()">æ›´æ–°</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // WebGL æ”¯æŒæ£€æµ‹
        function testWebGLSupport() {
            const resultDiv = document.getElementById('webgl-support-result');
            
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || 
                          canvas.getContext('experimental-webgl') ||
                          canvas.getContext('webgl2');
                
                if (gl) {
                    const version = gl.getParameter(gl.VERSION);
                    const vendor = gl.getParameter(gl.VENDOR);
                    const renderer = gl.getParameter(gl.RENDERER);
                    
                    resultDiv.className = 'test-result success';
                    resultDiv.innerHTML = `
                        âœ… WebGL æ”¯æŒæ­£å¸¸<br>
                        ç‰ˆæœ¬: ${version}<br>
                        å‚å•†: ${vendor}<br>
                        æ¸²æŸ“å™¨: ${renderer}
                    `;
                } else {
                    resultDiv.className = 'test-result error';
                    resultDiv.innerHTML = 'âŒ WebGL ä¸æ”¯æŒæˆ–å·²è¢«ç¦ç”¨';
                }
            } catch (error) {
                resultDiv.className = 'test-result error';
                resultDiv.innerHTML = `âŒ WebGL æ£€æµ‹å¤±è´¥: ${error.message}`;
            }
        }
        
        // æµ‹è¯•ä¸åŒçš„ WebGL ä¸Šä¸‹æ–‡
        function testWebGLContexts() {
            const canvas = document.createElement('canvas');
            const contexts = [
                { name: 'webgl', context: canvas.getContext('webgl') },
                { name: 'experimental-webgl', context: canvas.getContext('experimental-webgl') },
                { name: 'webgl2', context: canvas.getContext('webgl2') }
            ];
            
            let result = 'WebGL ä¸Šä¸‹æ–‡æµ‹è¯•ç»“æœ:<br>';
            contexts.forEach(({ name, context }) => {
                if (context) {
                    result += `âœ… ${name}: æ”¯æŒ<br>`;
                } else {
                    result += `âŒ ${name}: ä¸æ”¯æŒ<br>`;
                }
            });
            
            const resultDiv = document.getElementById('webgl-support-result');
            resultDiv.className = 'test-result ' + (contexts.some(c => c.context) ? 'success' : 'error');
            resultDiv.innerHTML = result;
        }
        
        // æ˜¾ç¤º WebGL ä¿¡æ¯
        function displayWebGLInfo() {
            const infoDiv = document.getElementById('webgl-info');
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) {
                infoDiv.innerHTML = '<div class="info-item"><div class="info-label">çŠ¶æ€</div><div class="info-value">WebGL ä¸å¯ç”¨</div></div>';
                return;
            }
            
            const info = {
                'WebGL ç‰ˆæœ¬': gl.getParameter(gl.VERSION),
                'å‚å•†': gl.getParameter(gl.VENDOR),
                'æ¸²æŸ“å™¨': gl.getParameter(gl.RENDERER),
                'ç€è‰²å™¨è¯­è¨€ç‰ˆæœ¬': gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
                'æœ€å¤§çº¹ç†å¤§å°': gl.getParameter(gl.MAX_TEXTURE_SIZE),
                'æœ€å¤§è§†å£å°ºå¯¸': gl.getParameter(gl.MAX_VIEWPORT_DIMS),
                'æœ€å¤§é¡¶ç‚¹å±æ€§': gl.getParameter(gl.MAX_VERTEX_ATTRIBS),
                'æœ€å¤§çº¹ç†å•å…ƒ': gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),
                'æœ€å¤§é¡¶ç‚¹çº¹ç†å•å…ƒ': gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
                'æœ€å¤§æ¸²æŸ“ç¼“å†²åŒºå¤§å°': gl.getParameter(gl.MAX_RENDERBUFFER_SIZE),
                'æœ€å¤§é¡¶ç‚¹ç»Ÿä¸€å‘é‡': gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
                'æœ€å¤§ç‰‡æ®µç»Ÿä¸€å‘é‡': gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),
                'æœ€å¤§å˜åŒ–å‘é‡': gl.getParameter(gl.MAX_VARYING_VECTORS)
            };
            
            let html = '';
            for (const [label, value] of Object.entries(info)) {
                html += `
                    <div class="info-item">
                        <div class="info-label">${label}</div>
                        <div class="info-value">${value}</div>
                    </div>
                `;
            }
            infoDiv.innerHTML = html;
        }
        
        // æµ‹è¯• WebGL 1.0 Canvas
        function testWebGL1() {
            const canvas = document.getElementById('webgl1-canvas');
            const resultDiv = document.getElementById('webgl1-result');
            
            try {
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    resultDiv.className = 'test-result error';
                    resultDiv.textContent = 'âŒ WebGL 1.0 ä¸å¯ç”¨';
                    return;
                }
                
                // ç®€å•çš„ WebGL æ¸²æŸ“
                gl.clearColor(0.2, 0.4, 0.8, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                // ç»˜åˆ¶ä¸€ä¸ªç®€å•çš„ä¸‰è§’å½¢
                const vertices = new Float32Array([
                    0.0, 0.5, 0.0,
                    -0.5, -0.5, 0.0,
                    0.5, -0.5, 0.0
                ]);
                
                const vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `
                    attribute vec3 position;
                    void main() {
                        gl_Position = vec4(position, 1.0);
                    }
                `);
                gl.compileShader(vertexShader);
                
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, `
                    void main() {
                        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                    }
                `);
                gl.compileShader(fragmentShader);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                gl.useProgram(program);
                
                const positionLocation = gl.getAttribLocation(program, 'position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0);
                
                gl.drawArrays(gl.TRIANGLES, 0, 3);
                
                resultDiv.className = 'test-result success';
                resultDiv.textContent = 'âœ… WebGL 1.0 æ¸²æŸ“æˆåŠŸ';
            } catch (error) {
                resultDiv.className = 'test-result error';
                resultDiv.textContent = `âŒ WebGL 1.0 æ¸²æŸ“å¤±è´¥: ${error.message}`;
            }
        }
        
        // æµ‹è¯• WebGL 2.0 Canvas
        function testWebGL2() {
            const canvas = document.getElementById('webgl2-canvas');
            const resultDiv = document.getElementById('webgl2-result');
            
            try {
                const gl = canvas.getContext('webgl2');
                if (!gl) {
                    resultDiv.className = 'test-result warning';
                    resultDiv.textContent = 'âš ï¸ WebGL 2.0 ä¸å¯ç”¨';
                    return;
                }
                
                // ç®€å•çš„ WebGL 2.0 æ¸²æŸ“
                gl.clearColor(0.8, 0.2, 0.4, 1.0);
                gl.clear(gl.COLOR_BUFFER_BIT);
                
                // ç»˜åˆ¶ä¸€ä¸ªç®€å•çš„çŸ©å½¢
                const vertices = new Float32Array([
                    -0.5, -0.5,
                     0.5, -0.5,
                    -0.5,  0.5,
                     0.5,  0.5
                ]);
                
                const vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `
                    #version 300 es
                    in vec2 position;
                    void main() {
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `);
                gl.compileShader(vertexShader);
                
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, `
                    #version 300 es
                    precision mediump float;
                    out vec4 fragColor;
                    void main() {
                        fragColor = vec4(1.0, 0.8, 0.2, 1.0);
                    }
                `);
                gl.compileShader(fragmentShader);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                gl.useProgram(program);
                
                const positionLocation = gl.getAttribLocation(program, 'position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                
                resultDiv.className = 'test-result success';
                resultDiv.textContent = 'âœ… WebGL 2.0 æ¸²æŸ“æˆåŠŸ';
            } catch (error) {
                resultDiv.className = 'test-result error';
                resultDiv.textContent = `âŒ WebGL 2.0 æ¸²æŸ“å¤±è´¥: ${error.message}`;
            }
        }
        
        // æµ‹è¯• 2D Canvas
        function test2DCanvas() {
            const canvas = document.getElementById('2d-canvas');
            const ctx = canvas.getContext('2d');
            
            // ç»˜åˆ¶æ¸å˜èƒŒæ™¯
            const gradient = ctx.createLinearGradient(0, 0, 200, 150);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(1, '#764ba2');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 200, 150);
            
            // ç»˜åˆ¶ä¸€äº›å›¾å½¢
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(100, 75, 30, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('2D Canvas', 100, 80);
        }
        
        // æµ‹è¯•æ‰€æœ‰ Canvas
        function testAllCanvases() {
            testWebGL1();
            testWebGL2();
            test2DCanvas();
        }
        
        // æ¸…ç©ºæ‰€æœ‰ Canvas
        function clearAllCanvases() {
            const canvases = ['webgl1-canvas', 'webgl2-canvas', '2d-canvas'];
            canvases.forEach(id => {
                const canvas = document.getElementById(id);
                const ctx = canvas.getContext('2d') || canvas.getContext('webgl') || canvas.getContext('webgl2');
                if (ctx) {
                    if (ctx.clear) {
                        ctx.clear(0, 0, canvas.width, canvas.height);
                    } else {
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                    }
                }
            });
        }
        
        // æ¨¡æ‹Ÿæ‰©å±•ç¯å¢ƒæµ‹è¯•
        function testExtensionEnvironment() {
            const resultDiv = document.getElementById('extension-test-result');
            
            try {
                // æ¨¡æ‹Ÿæ‰©å±•ç¯å¢ƒçš„é™åˆ¶
                const tests = [
                    {
                        name: 'Canvas åˆ›å»º',
                        test: () => document.createElement('canvas')
                    },
                    {
                        name: 'WebGL ä¸Šä¸‹æ–‡è·å–',
                        test: () => {
                            const canvas = document.createElement('canvas');
                            return canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                        }
                    },
                    {
                        name: 'WebGL åŠŸèƒ½æ£€æŸ¥',
                        test: () => {
                            const canvas = document.createElement('canvas');
                            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                            if (!gl) return false;
                            return gl.getParameter(gl.VERSION) && gl.getParameter(gl.VENDOR);
                        }
                    }
                ];
                
                let result = 'æ‰©å±•ç¯å¢ƒæ¨¡æ‹Ÿæµ‹è¯•:<br>';
                let allPassed = true;
                
                tests.forEach(({ name, test }) => {
                    try {
                        const ok = test();
                        if (ok) {
                            result += `âœ… ${name}: é€šè¿‡<br>`;
                        } else {
                            result += `âŒ ${name}: å¤±è´¥<br>`;
                            allPassed = false;
                        }
                    } catch (error) {
                        result += `âŒ ${name}: é”™è¯¯ - ${error.message}<br>`;
                        allPassed = false;
                    }
                });
                
                resultDiv.className = 'test-result ' + (allPassed ? 'success' : 'error');
                resultDiv.innerHTML = result;
            } catch (error) {
                resultDiv.className = 'test-result error';
                resultDiv.innerHTML = `âŒ æ‰©å±•ç¯å¢ƒæµ‹è¯•å¤±è´¥: ${error.message}`;
            }
        }
        
        // æµ‹è¯•æ‰©å±•ä¸­çš„ WebGL
        function testWebGLInExtension() {
            const resultDiv = document.getElementById('extension-test-result');
            
            try {
                // ä½¿ç”¨ä¸æ‰©å±•ç›¸åŒçš„æ£€æµ‹é€»è¾‘
                const canvas = document.createElement('canvas');
                const contextAttributes = {
                    alpha: true,
                    antialias: false,
                    depth: false,
                    failIfMajorPerformanceCaveat: false,
                    powerPreference: 'default',
                    premultipliedAlpha: false,
                    preserveDrawingBuffer: false,
                    stencil: false
                };
                
                const gl = canvas.getContext('webgl', contextAttributes) || 
                          canvas.getContext('experimental-webgl', contextAttributes) ||
                          canvas.getContext('webgl2', contextAttributes);
                
                if (gl) {
                    const version = gl.getParameter(gl.VERSION);
                    const vendor = gl.getParameter(gl.VENDOR);
                    const renderer = gl.getParameter(gl.RENDERER);
                    
                    resultDiv.className = 'test-result success';
                    resultDiv.innerHTML = `
                        âœ… æ‰©å±•ç¯å¢ƒ WebGL æµ‹è¯•é€šè¿‡<br>
                        ç‰ˆæœ¬: ${version}<br>
                        å‚å•†: ${vendor}<br>
                        æ¸²æŸ“å™¨: ${renderer}
                    `;
                } else {
                    resultDiv.className = 'test-result error';
                    resultDiv.innerHTML = 'âŒ æ‰©å±•ç¯å¢ƒä¸­ WebGL ä¸å¯ç”¨';
                }
            } catch (error) {
                resultDiv.className = 'test-result error';
                resultDiv.innerHTML = `âŒ æ‰©å±•ç¯å¢ƒ WebGL æµ‹è¯•å¤±è´¥: ${error.message}`;
            }
        }
        
        // WebGL æ€§èƒ½æµ‹è¯•
        function testWebGLPerformance() {
            const resultDiv = document.getElementById('performance-result');
            
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                
                if (!gl) {
                    resultDiv.className = 'test-result error';
                    resultDiv.textContent = 'âŒ WebGL ä¸å¯ç”¨ï¼Œæ— æ³•è¿›è¡Œæ€§èƒ½æµ‹è¯•';
                    return;
                }
                
                const startTime = performance.now();
                
                // åˆ›å»ºç®€å•çš„ç€è‰²å™¨ç¨‹åº
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, `
                    attribute vec2 position;
                    void main() {
                        gl_Position = vec4(position, 0.0, 1.0);
                    }
                `);
                gl.compileShader(vertexShader);
                
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, `
                    precision mediump float;
                    void main() {
                        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                    }
                `);
                gl.compileShader(fragmentShader);
                
                const program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                gl.useProgram(program);
                
                // åˆ›å»ºé¡¶ç‚¹ç¼“å†²åŒº
                const vertices = new Float32Array([
                    -1, -1, 1, -1, -1, 1, 1, 1
                ]);
                const vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                const positionLocation = gl.getAttribLocation(program, 'position');
                gl.enableVertexAttribArray(positionLocation);
                gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
                
                // æ‰§è¡Œå¤šæ¬¡æ¸²æŸ“
                const iterations = 1000;
                for (let i = 0; i < iterations; i++) {
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                }
                
                const endTime = performance.now();
                const duration = endTime - startTime;
                const fps = (iterations / duration) * 1000;
                
                resultDiv.className = 'test-result success';
                resultDiv.innerHTML = `
                    âœ… WebGL æ€§èƒ½æµ‹è¯•å®Œæˆ<br>
                    æ¸²æŸ“æ¬¡æ•°: ${iterations}<br>
                    æ€»è€—æ—¶: ${duration.toFixed(2)}ms<br>
                    å¹³å‡ FPS: ${fps.toFixed(2)}
                `;
            } catch (error) {
                resultDiv.className = 'test-result error';
                resultDiv.textContent = `âŒ WebGL æ€§èƒ½æµ‹è¯•å¤±è´¥: ${error.message}`;
            }
        }
        
        // Canvas 2D æ€§èƒ½æµ‹è¯•
        function testCanvasPerformance() {
            const resultDiv = document.getElementById('performance-result');
            
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 200;
                canvas.height = 150;
                const ctx = canvas.getContext('2d');
                
                const startTime = performance.now();
                
                // æ‰§è¡Œå¤šæ¬¡ç»˜åˆ¶
                const iterations = 1000;
                for (let i = 0; i < iterations; i++) {
                    ctx.clearRect(0, 0, 200, 150);
                    ctx.fillStyle = `hsl(${i % 360}, 50%, 50%)`;
                    ctx.fillRect(50, 50, 100, 50);
                }
                
                const endTime = performance.now();
                const duration = endTime - startTime;
                const fps = (iterations / duration) * 1000;
                
                resultDiv.className = 'test-result success';
                resultDiv.innerHTML = `
                    âœ… Canvas 2D æ€§èƒ½æµ‹è¯•å®Œæˆ<br>
                    ç»˜åˆ¶æ¬¡æ•°: ${iterations}<br>
                    æ€»è€—æ—¶: ${duration.toFixed(2)}ms<br>
                    å¹³å‡ FPS: ${fps.toFixed(2)}
                `;
            } catch (error) {
                resultDiv.className = 'test-result error';
                resultDiv.textContent = `âŒ Canvas 2D æ€§èƒ½æµ‹è¯•å¤±è´¥: ${error.message}`;
            }
        }
        
        // å®æ—¶æ¸²æŸ“ç›¸å…³å˜é‡
        let realTimeRendering = false;
        let animationId = null;
        let time = 0;

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è¿è¡Œæµ‹è¯•
        window.addEventListener('load', () => {
            testWebGLSupport();
            displayWebGLInfo();
            test2DCanvas();
            testWebGPUSupport();
            // ä¸è‡ªåŠ¨å¼€å§‹å®æ—¶æ¸²æŸ“ï¼Œè®©ç”¨æˆ·æ‰‹åŠ¨æ§åˆ¶
        });

        // ===== æ¯›ç»ç’ƒ Tag å®æ—¶æ¸²æŸ“ =====
        function toggleRealTimeRendering() {
            if (realTimeRendering) {
                stopRealTimeRendering();
            } else {
                startRealTimeRendering();
            }
        }

        function startRealTimeRendering() {
            realTimeRendering = true;
            time = 0;
            const resultDiv = document.getElementById('glass-tag-result');
            resultDiv.className = 'test-result success';
            resultDiv.textContent = 'âœ… å®æ—¶æ¸²æŸ“å·²å¯åŠ¨';
            renderLoop();
        }

        function stopRealTimeRendering() {
            realTimeRendering = false;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            const resultDiv = document.getElementById('glass-tag-result');
            resultDiv.className = 'test-result warning';
            resultDiv.textContent = 'â¸ï¸ å®æ—¶æ¸²æŸ“å·²åœæ­¢';
        }

        function renderLoop() {
            if (!realTimeRendering) return;
            
            drawGlassTagRealTime();
            time += 0.016; // çº¦60fps
            animationId = requestAnimationFrame(renderLoop);
        }

        function drawGlassTagRealTime() {
            const canvas = document.getElementById('glass-tag-canvas');
            const ctx = canvas.getContext('2d');
            const w = canvas.width, h = canvas.height;
            const pillX = 20, pillY = 20, pillW = w - 40, pillH = 40, r = 20;
            const text = (document.getElementById('glass-tag-text').value || 'GameplayTag').slice(0, 30);
            const enableAnimation = document.getElementById('enable-animation').checked;
            const enableNoise = document.getElementById('enable-noise').checked;

            // æ¸…ç©º
            ctx.clearRect(0, 0, w, h);

            // åŠ¨æ€èƒŒæ™¯ï¼ˆæ¨¡æ‹Ÿç¯å¢ƒå˜åŒ–ï¼‰
            const bgGrad = ctx.createLinearGradient(0, 0, w, h);
            if (enableAnimation) {
                const hue1 = (240 + Math.sin(time * 0.5) * 20) % 360;
                const hue2 = (280 + Math.cos(time * 0.3) * 15) % 360;
                bgGrad.addColorStop(0, `hsl(${hue1}, 60%, 50%)`);
                bgGrad.addColorStop(1, `hsl(${hue2}, 70%, 45%)`);
            } else {
                bgGrad.addColorStop(0, '#667eea');
                bgGrad.addColorStop(1, '#764ba2');
            }
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, w, h);

            // ç»ç’ƒä¸»ä½“
            ctx.save();
            roundRectPath(ctx, pillX, pillY, pillW, pillH, r);
            ctx.clip();

            // åŠ¨æ€ç»ç’ƒåº•è‰²
            const glassGrad = ctx.createLinearGradient(0, pillY, 0, pillY + pillH);
            if (enableAnimation) {
                const alpha1 = 0.15 + Math.sin(time * 2) * 0.08;
                const alpha2 = 0.08 + Math.cos(time * 1.5) * 0.05;
                glassGrad.addColorStop(0, `rgba(255,255,255,${alpha1})`);
                glassGrad.addColorStop(1, `rgba(255,255,255,${alpha2})`);
            } else {
                glassGrad.addColorStop(0, 'rgba(255,255,255,0.22)');
                glassGrad.addColorStop(1, 'rgba(255,255,255,0.10)');
            }
            ctx.fillStyle = glassGrad;
            ctx.fillRect(pillX, pillY, pillW, pillH);

            // åŠ¨æ€å†…éƒ¨é«˜å…‰
            if (enableAnimation) {
                const highlightAlpha = 0.2 + Math.sin(time * 3) * 0.1;
                ctx.fillStyle = `rgba(255,255,255,${highlightAlpha})`;
                ctx.fillRect(pillX, pillY, pillW, 1);
                
                // ç§»åŠ¨çš„å…‰æ–‘æ•ˆæœ
                const lightX = pillX + (Math.sin(time * 2) * 0.5 + 0.5) * pillW;
                const lightGrad = ctx.createRadialGradient(lightX, pillY + pillH/2, 0, lightX, pillY + pillH/2, pillW/2);
                lightGrad.addColorStop(0, 'rgba(255,255,255,0.3)');
                lightGrad.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = lightGrad;
                ctx.fillRect(pillX, pillY, pillW, pillH);
            } else {
                ctx.fillStyle = 'rgba(255,255,255,0.25)';
                ctx.fillRect(pillX, pillY, pillW, 1);
            }

            // å™ªå£°æ•ˆæœ
            if (enableNoise) {
                addNoise(ctx, pillX, pillY, pillW, pillH, 0.03 + Math.sin(time) * 0.02);
            }

            ctx.restore();

            // åŠ¨æ€è¾¹æ¡†
            if (enableAnimation) {
                const borderAlpha = 0.25 + Math.sin(time * 1.5) * 0.1;
                ctx.strokeStyle = `rgba(255,255,255,${borderAlpha})`;
            } else {
                ctx.strokeStyle = 'rgba(255,255,255,0.35)';
            }
            ctx.lineWidth = 1;
            roundRectPath(ctx, pillX, pillY, pillW, pillH, r);
            ctx.stroke();

            // åŠ¨æ€é˜´å½±
            ctx.save();
            if (enableAnimation) {
                const shadowBlur = 12 + Math.sin(time * 0.8) * 4;
                const shadowOffset = 4 + Math.cos(time * 1.2) * 2;
                ctx.shadowColor = `rgba(0,0,0,${0.15 + Math.sin(time) * 0.07})`;
                ctx.shadowBlur = shadowBlur;
                ctx.shadowOffsetY = shadowOffset;
            } else {
                ctx.shadowColor = 'rgba(0,0,0,0.22)';
                ctx.shadowBlur = 16;
                ctx.shadowOffsetY = 6;
            }
            roundRectPath(ctx, pillX, pillY, pillW, pillH, r);
            ctx.strokeStyle = 'rgba(0,0,0,0)';
            ctx.stroke();
            ctx.restore();

            // æ–‡æœ¬ï¼ˆå¸¦è½»å¾®åŠ¨ç”»ï¼‰
            ctx.fillStyle = '#ffffff';
            ctx.font = '600 16px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            if (enableAnimation) {
                const textOffsetY = Math.sin(time * 2) * 0.5;
                ctx.fillText(text, pillX + pillW / 2, pillY + pillH / 2 + 1 + textOffsetY);
            } else {
                ctx.fillText(text, pillX + pillW / 2, pillY + pillH / 2 + 1);
            }
        }

        function roundRectPath(ctx, x, y, w, h, r) {
            const rr = Math.min(r, w / 2, h / 2);
            ctx.beginPath();
            ctx.moveTo(x + rr, y);
            ctx.arcTo(x + w, y, x + w, y + h, rr);
            ctx.arcTo(x + w, y + h, x, y + h, rr);
            ctx.arcTo(x, y + h, x, y, rr);
            ctx.arcTo(x, y, x + w, y, rr);
            ctx.closePath();
        }

        function addNoise(ctx, x, y, w, h, alpha = 0.05) {
            const imageData = ctx.getImageData(x, y, w, h);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const n = (Math.random() * 255) | 0;
                data[i] = data[i] * 1 + n * alpha;     // R
                data[i+1] = data[i+1] * 1 + n * alpha; // G
                data[i+2] = data[i+2] * 1 + n * alpha; // B
            }
            ctx.putImageData(imageData, x, y);
        }

        // CSS ç»ç’ƒæ ‡ç­¾æ–‡æœ¬æ›´æ–°
        function updateCssGlassTag() {
            const el = document.getElementById('glass-tag-css');
            const input = document.getElementById('glass-tag-css-text');
            el.textContent = (input.value || 'GameplayTag').slice(0, 30);
        }

        // è¾“å…¥æ¡†å®æ—¶æ›´æ–°
        document.addEventListener('DOMContentLoaded', () => {
            const textInput = document.getElementById('glass-tag-text');
            if (textInput) {
                textInput.addEventListener('input', () => {
                    // å¦‚æœæ­£åœ¨å®æ—¶æ¸²æŸ“ï¼Œæ–‡æœ¬ä¼šç«‹å³æ›´æ–°
                    // å¦‚æœæ²¡æœ‰å®æ—¶æ¸²æŸ“ï¼Œå¯ä»¥æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡æ¸²æŸ“
                    if (!realTimeRendering) {
                        drawGlassTagRealTime();
                    }
                });
            }
        });

        // ===== WebGPU æ£€æµ‹ä¸æµ‹è¯• =====
        async function testWebGPUSupport() {
            const div = document.getElementById('webgpu-support-result');
            if (!('gpu' in navigator)) {
                div.className = 'test-result error';
                div.innerHTML = 'âŒ å½“å‰ç¯å¢ƒä¸æ”¯æŒ WebGPU (ç¼ºå°‘ navigator.gpu)';
                return;
            }
            try {
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    div.className = 'test-result warning';
                    div.innerHTML = 'âš ï¸ æ‰¾ä¸åˆ°å¯ç”¨çš„ WebGPU Adapter';
                    return;
                }
                const info = adapter.info || {};
                div.className = 'test-result success';
                div.innerHTML = `âœ… WebGPU å¯ç”¨<br>Vendor: ${info.vendor || 'æœªçŸ¥'}<br>Architecture: ${info.architecture || 'æœªçŸ¥'}<br>Device: ${info.device || 'æœªçŸ¥'}`;
            } catch (e) {
                div.className = 'test-result error';
                div.innerHTML = `âŒ WebGPU æ£€æµ‹å¤±è´¥: ${e.message}`;
            }
        }

        async function testWebGPUAdapterDevice() {
            const div = document.getElementById('webgpu-support-result');
            try {
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    div.className = 'test-result warning';
                    div.innerHTML = 'âš ï¸ æ— æ³•è·å– Adapter';
                    return;
                }
                const device = await adapter.requestDevice();
                const limits = device.limits || {};
                div.className = 'test-result success';
                div.innerHTML = `âœ… è·å– Adapter/Device æˆåŠŸ<br>maxTextureDimension2D: ${limits.maxTextureDimension2D}`;
                device.destroy?.();
            } catch (e) {
                div.className = 'test-result error';
                div.innerHTML = `âŒ è·å– Adapter/Device å¤±è´¥: ${e.message}`;
            }
        }

        async function testWebGPUCanvas() {
            const resultDiv = document.getElementById('webgpu-result');
            const canvas = document.getElementById('webgpu-canvas');
            if (!('gpu' in navigator)) {
                resultDiv.className = 'test-result error';
                resultDiv.textContent = 'âŒ ä¸æ”¯æŒ WebGPU';
                return;
            }
            try {
                const adapter = await navigator.gpu.requestAdapter();
                if (!adapter) {
                    resultDiv.className = 'test-result warning';
                    resultDiv.textContent = 'âš ï¸ æ‰¾ä¸åˆ° WebGPU Adapter';
                    return;
                }
                const device = await adapter.requestDevice();
                const context = canvas.getContext('webgpu');
                const format = navigator.gpu.getPreferredCanvasFormat();
                context.configure({ device, format, alphaMode: 'premultiplied' });

                // æäº¤ä¸€æ¬¡æ¸…å±æ¸²æŸ“é€šé“
                const encoder = device.createCommandEncoder();
                const textureView = context.getCurrentTexture().createView();
                const pass = encoder.beginRenderPass({
                    colorAttachments: [{
                        view: textureView,
                        clearValue: { r: 0.1, g: 0.6, b: 0.9, a: 1.0 },
                        loadOp: 'clear',
                        storeOp: 'store'
                    }]
                });
                pass.end();
                const commandBuffer = encoder.finish();
                device.queue.submit([commandBuffer]);

                resultDiv.className = 'test-result success';
                resultDiv.textContent = 'âœ… WebGPU æ¸…å±æ¸²æŸ“æˆåŠŸ';
            } catch (e) {
                resultDiv.className = 'test-result error';
                resultDiv.textContent = `âŒ WebGPU æ¸²æŸ“å¤±è´¥: ${e.message}`;
            }
        }
    </script>
</body>
</html>
